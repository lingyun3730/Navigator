数据结构

数组 （二分查找，排序，双指针，滑动窗口，dp）
链表  (删除，查找，旋转，倒置，相交，成环, random深拷贝）
字符串 （双指针，滑动窗口，dp, KMP, 回文串）
哈希表
树：二叉树 (前中后序遍历递归和非递归，bst的查找删除插入，树高，最长路径)，字典树
栈 （单调栈）
队列 （双向队列，单调队列 ：滑动窗口求最大值）
堆 （优先级队列 ：topK）
并查集


算法

DFS backtracking （模版）
DFS + memo  (top - down) （模版）
DP （五部曲）
BFS （模板）
贪心 （无套路，局部最优->全局最优）
图论 （DAG, 临接矩阵和临接表)
位运算

其他题目：
LRU cache
实现一个blocking queue


薄弱点或者可能会遗忘的点：
1. LRU (done)
2. KMP （done 28, 459)
3. blocking queue
4. 二叉树的非递归遍历
5. 树形dp，博弈型dp （done)
 * 树形dp, 每个节点都有取和不取两种状态，因此状态int[2]作为返回值，进行dfs + memo (Map<Integer, int[]>), 取和不取对是否取子节点有影响。

 * 博弈型dp, 对角线填充, totally bottom -> up, 二维dp
 *
 * dp[i][j][0] 表示面对i-j的红包自己作为先手的最大收益
 * dp[i][j][1] 表示面对i-j的红包自己作为后手的最大收益
 * 先对角线初始化，然后数组填充从下向上从左向右 i : [n-1,0], j : [i+1, n-1]
 * dp[i][j][0] = max(dp[i+1][j][1] + data[i], dp[i][j-1][1] + data[j])
 * dp[i][j][1] = dp[i+1][j][1] + data[i] > dp[i][j-1][1] + data[j]? dp[i+1][j][0] : dp[i][j-1][0]

6. 最近公共祖先 LC236 (done)
7. 分割问题 93 backtracking, 按照组合问题的方式来做，考虑细节比如字符串长度超过12以及小于4，分割出来的数字首位不能为0。（done)
8. LC 332, 航班路线问题，找到一条路就返回，属于递归有返回值boolean的类型，同类型的题目还有数独问题37 (done)
9. java的容器Deque, Queue, Stack ...
10. top - down / bottom - up 经典题 LC 132 (done) 可以再复习下
11. 二分法的循环不变量，[start, end) 和 [start, end]
12. 动态规划 LIS 高阶， 673. 两个数组dp[i], count[i] (done)


backtracking:
1. 组合问题是一个pattern, index, i， 只取到叶子节点的路径
2. 子集问题在组合问题的基础上， 取到所有的节点的路径
3. 分割问题的本质还是组合问题，只是呈现方式略有不同，需要特殊建模

关于递归什么时候有返回值什么时候没有返回值。
1. 要遍历整棵树来求所有解，并且不需要处理递归的中间结果，只是将结果收集的情况，不需要返回值。（大部分题目）
2. 要遍历整棵树求所有解，但是需要处理递归的中间结果，需要返回值。（比如LC 326最近公共祖先，LC 437 path sum III）
3. 求一条通路，找到就返回，需要在找到答案时就返回。 （比如 LC 332，和求数独LC 37)


回文类的题目分为两类：（遍历顺序都是从下到上，从左往右）
1.回文子串 : 连续的，一般构造的二维dp数组是boolean类型的，表示i->j之间的字符串是否构成回文串，其实不需要提前填充数组 LC 5
2.回文子序列 : 不连续的，一般构造的二维dp数组是int类型的，表示i->j之间的子序列中的最长子序列是多少，需要提前对对角线数组进行填充 LC 516
3.回文串的分割问题可以用 top -> down，也就是dfs + memo，也可以用bottom-up用dp做，经典题比如 LC 132， 1745

