数据结构

数组 （二分查找，排序，双指针，滑动窗口，dp）
链表  (删除，查找，旋转，倒置，相交，成环, random深拷贝）
字符串 （双指针，滑动窗口，dp, KMP, 回文串）
哈希表
树：二叉树 (前中后序遍历递归和非递归，bst的查找删除插入，树高，最长路径)，字典树
栈 （单调栈）
队列 （双向队列，单调队列 ：滑动窗口求最大值）
堆 （优先级队列 ：topK）
并查集


算法

DFS backtracking （模版）
DFS + memo  (top - down) （模版）
DP （五部曲）
BFS （模板）
贪心 （无套路，局部最优->全局最优）
图论 （DAG, 临接矩阵和临接表)
位运算

其他题目：
LRU cache
实现一个blocking queue


薄弱点或者可能会遗忘的点：
1. LRU (done)
2. KMP
3. blocking queue
4. 二叉树的非递归遍历
5. 树形dp，博弈型dp （done)
 * 树形dp, 每个节点都有取和不取两种状态，因此状态int[2]作为返回值，进行dfs + memo (Map<Integer, int[]>), 取和不取对是否取子节点有影响。

 * 博弈型dp, 对角线填充, totally bottom -> up, 二维dp
 *
 * dp[i][j][0] 表示面对i-j的红包自己作为先手的最大收益
 * dp[i][j][1] 表示面对i-j的红包自己作为后手的最大收益
 * 先对角线初始化，然后数组填充 i : [n-1,0], j : [i+1, n-1]
 * dp[i][j][0] = max(dp[i+1][j][1] + data[i], dp[i][j-1][1] + data[j])
 * dp[i][j][1] = dp[i+1][j][1] + data[i] > dp[i][j-1][1] + data[j]? dp[i+1][j][0] : dp[i][j-1][0]

6. 最近公共祖先 LC236
7. 分割问题 93 backtracking
8. LC 332, 673
9. java的容器Deque, Queue, Stack ...
10. top - down / bottom - up 经典题 LC 132
11. 二分法的循环不变量，[start, end) 和 [start, end]


backtracking:
1. 组合问题是一个pattern, index, i， 只取到叶子节点的路径
2. 子集问题在组合问题的基础上， 取到所有的节点的路径
3. 分割问题的本质还是组合问题，只是呈现方式略有不同，需要特殊建模


