package com.sata.dp.regular;
/**
 * LC 1411
 */
public class NumberOfPaints {
    public int numOfWays(int n) {
        //数学找规律的题目，动态规划
        //dp[i][0]表示第i行用两种颜色涂色的可能性
        //dp[i][1]表示第i行用三种颜色涂色的可能性
        //由于第i行仅仅和上一行i-1相关，因此，dp[i][0]从dp[i-1][0]和dp[i-1][1]递推得到
        //同理，dp[i][1]也从dp[i-1][0]和dp[i-1][1]递推得到
        //剩下的工作就是找到递推关系了。
        //很容易发现， dp[i][0] = 3 * dp[i-1][0] + 2 * dp[i-1][1];
        //dp[i][1] = 2 * dp[i-1][0] + 2 * dp[i-1][1];
        //解释就是，如果上一行是ABA，则本行是ABA的有三种可能性，是ABC的有两种可能性，如果上一层是
        //ABC，则下一行是ABA有两种可能性，是ABC也有两种可能性。
        //比如i-1行是010, 则i行可能是101，202，121三种ABA的类型，和102，201两种ABC类型组合
        //相反，第i-1行是012，则第i行可能是101，121两种ABA类型，和120，201两种ABC类型组合。
//        long[][] dp = new long[n+1][2];
//        dp[1][0] = 6;
//        dp[1][1] = 6;
//        for(int i = 2; i <= n; i++) {
//            dp[i][0] = (dp[i-1][0] * 3 + dp[i-1][1] * 2) % 1000000007;
//            dp[i][1] = (dp[i-1][0] * 2 + dp[i-1][1] * 2) % 1000000007;
//        }
//        return (int) ((dp[n][0] + dp[n][1]) % 1000000007);
        long x = 6, y = 6;
        for(int i = 2; i <= n; i++) {
            long tmp = x;
            x = (x * 3 + y * 2) % 1000000007;
            y = (tmp * 2 + y * 2) % 1000000007;
        }
        return (int) (x + y) % 1000000007;

    }
}
